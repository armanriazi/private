---
tags:
  - podcast
  - dr.gavinwood
---


## Relay Chain PodCast 1(Dr.gavin wood)

### Substrate
> Substrate have a strong engineering core

### Policy&Security

**Dr{**
> Nation state vs Decentralized(dao,dac,protocol).  

> The virtue of technology is essential when we have trusted platforms. 

> Facebook does not ==guarantee the privacy== of users. 

> It's difficult to ==trust== governments and companies.

> It is almost impossible to agree on any kind of global ==firewall== .Potential Malicious actor or attack.

**}**

### SmartContract

**Dr{**
> Unexpected State transition because of some bug, in a contract.

>Eth 2: The kind of smart contract model, although it does allow for that but to be used, but also for more fixed function pipeline, fixed function, transaction processing to be done. That can give much greater performance gains.

**}**

[[Governance]]

**Dr{**

> That's the point of governance. It's basically to work out this really soft notion of how many people expected it to do, X versus how many people expected it due to Y and the strength of those expectations.

> ==Lock-voting== system So they are refreshed in a sort of ==round-robin== files fashion so that none of them.
**}**

[[Security]]

**Dr{**
> Principle versus Pragmatism is needed for the detection of balance lies.

**}**

[[Skill]]

**Dr{**
> What do you think are the most important skills to have? And, what areas are lacking in the industry? 

> Deep thought is a really important skill. I'm not sure if it's a skill or talent. The ability to consume and internalize a problem and understand it. 

**}**

### Economic

**Dr{**
> The rules that you can introduce would allow the emergent effects to become what it is that you want. That's an incredibly difficult thing to learn, but it's something that is very important in the world of sort of, you know, this trust-free digital crypto-economic world. 
**}**

### Problem

**Dr{**
> I think understanding better, which problems are better solved in a decentralized fashion and which problems are perfectly fine

**}**

### Transaction

**Dr{**

> High Transaction Outputs = Parallel Computing Blocks 

**}**

### Summery-PolkadotEcosystem

**Dr{**

> Domain-Specific Chain(it is not scratch)

> Chain candidate is launching a Genesis block. It is Launch of a new chain but the chain that has been launched is a proof of authority chain. It's a staging area for us to move further and what it does is it allows us to start the chain without having to have a sort of A set of validators already assembled and without us having to trust in our potentially unfilled governance structure.

> Although there's a Genesis block for it. It's not necessarily the Genesis block for the final polkadot chain.

> Initial chain restricted runtime will have its limitations be lifted through a series of governance decisions.

> During the first phase polka dot will operate as a purely proof of authority chain, to proof of authority. 

> Simply means that we have a number of authorities on behalf of the web three Foundation, fix the validator nodes and these validator nodes that will never change. They will always be operated by the 3 foundation and they will be the ones producing you. 

> ==The first is the pseudo module(& POA)= so this will allow the web 3 foundation to **upgrade the chain** as it desires the second pieces are pieces of functionality that can be used by the polka-dot community the first is allowing claims so that dot tokens or at least dot tokens sort of indicators can be claimed 

> The second piece(==NPOS==) of functionality allows those who hold dot token allocations to signal their intention to state and become validators or nominators for that matter this in this phase the only validators will be the web three foundations validator nodes but others can signal their intent and when we have enough people signaling their intent then we move to 

> Phase two the web 3 foundation will issue a sort of special command using its pseudo functionality using its pseudo permissions and we will switch from proof of authority to proof of stake and all of those stakes with their dot allocations that had signaled their intention to become validators they will be well at least some of them will be selected to ==become validators== and we will see the chain move from being operated merely by the web 3 foundation to being operated by an international selection of validators so while the chain is running under proof of authority it's really just trust in the web 3 foundation we have to expect this chain candidate to continue once it moves to proof of stake or nominated proof of stake our our variant of it then it will be quite different and we'll be trusting in the economics of our crypto economic logic now once the chain has been running well with a large validator set then the pseudo key will be used a second time and we will be able to move to phase

> Three phase three is where the pseudo key has enabled various pieces of governance to to function the governance a parachain of polkadot is fairly sophisticated now it's evolved alongside kusama I'm broadly speaking there are sort of four modules One is the 

> 3.1 ==Referendums module== allowing a coin weighted voting system that means that token holders are able to basically alter the fate of the polkadot network and the second is the 

> 3.2 ==Council module== allowing token holders to elect a number of members to the polkadot council both council doesn't actually have very much hard power but it is able to steer the legislative agenda and potentially remove dangerous upgrades that might be voted on by the the token holders the

> 3.3 Third element is the ==Technical Committe== this is a non voted body and it's selected simply by those teams that have properly implemented polka-dot it doesn't have any real substantial power but it is able to fast-track certain upgrades certain changes to the chain that they that it believes are important usually these will be bug fixes then the

> 3.4 Fourth piece of the governance a parachain is the ==Treasury== the Treasury allows the the council as well as various as well as the assembled token holders to to place funds that have been there have been a masked through the staking system through the block reward system and put them to use on things typically external to polka-dot whatever they may be again these are all elements of the kusama governance system and if you would like sort of to learn more about them you only need to look as far as kusama now what is the council and the various governance other governance modules are in place the public the dot token holders have the avenues to affect changes in the system basically the fate of polkadot is now in the hands of the token holders a 

> Final ==runtime upgrade== initiated by the web 3 foundation will remove the pseudo module and in doing so remove its omnipotent position as being able to cancel the chain as being able to create a new chain candidate at that point polka dot is a live decentralized and permissionless network the final stages of polka-dots rollout will be delivering the these extra pieces of functionality one of those extra pieces of functionality will be the balance transfers this will allow dot tokens to be transferable and not just an indicator and this will likely happen very soon after the pseudo module is released but of course we don't know what point because it will be in the hands of the dot token holders two more post pseudo upgrades will necessarily include the rollout of the first pair of chains and eventually para chain and para thread purchasing or leasing modules and 

> Finally the ==XCMP== cross power chain message passing system these will be rolled out as they become available as they are their code is finalized and as the audits are completed and will be done in concert between the various technical implementation teams the research teams and the dot holding community and that's.

> basically it launch a polka dot in five or six phases

>>  Kusuma have 1000 tips without any ZK snarks or lighting networks.

>> we have seamless upgrades that are controlled by the underlying logic of the consensus

>> Web 3 allows people come together and coordinate more

>> Dot is a amorphous protocol.

**}**


### NOPS

**Georgio{**

> We have these algorithms that work together, they're called babe and grandpa babies. 

> ...producing blocks and proposing. What the next stage change should be? And grandpa is for finalizing it...

> That's in this very polka dot specific in that validators are responsible for passing messages between parachains

#### NOPS-Consensus

> we're not really voting on blocks. But we're voting on chains.(
**WIKI-GRANDPA{**

> A pure Nakamoto consensus blockchain that runs PoW is only able to achieve the notion of ==probabilistic finality== and reach eventual consensus. Probabilistic finality means that under some assumptions about the network and participants, if we see a few blocks building on a given block, we can estimate the probability that it is final. Eventual consensus means that at some point in the future, all nodes will agree on the truthfulness of one set of data. This eventual consensus may take a long time and will not be able to be determined how long it will take ahead of time. 

> However, finality gadgets such as GRANDPA (GHOST-based Recursive ANcestor Deriving Prefix Agreement) or Ethereum's Casper FFG (the Friendly Finality Gadget) are designed to give stronger and quicker guarantees on the finality of blocks - specifically, that they can never be reverted after some process of Byzantine agreements has taken place. The notion of irreversible consensus is known as ==provable finality==.

> GRANDPA stands apart from other Byzantine fault-tolerant (==BFT==).The protocol applies votes transitively and the GRANDPA algorithm finds the highest block number with a sufficient number of votes to be considered final. This process allows several blocks to be finalized in one round.
**}**

**WIKI-BABE{**

> BABE (Blind Assignment for Blockchain Extension) is the ==block production== mechanism that runs between the validator nodes and determines the authors of new blocks. BABE is comparable as an algorithm to Ouroboros Praos, with some key differences in chain selection rule and slot time adjustments. BABE ==assigns block production slots to validators== according to stake and using the Polkadot randomness cycle.

> Validators in Polkadot will participate in a ==lottery in every slot== that will tell them whether or not they are the block producer candidate for that slot. ==Slots are discrete units of time==, **nominally 6 seconds** in length. Because of this randomness mechanism, multiple validators could be candidates for the same slot. Other times, a slot could be empty, resulting in inconsistent block time.
**}**
)

#### NOPS-Accounts

> Polka dots has two general types of accounts. Stash & controller.

> The stash account is something that should generally be capped offline.

> This would be like, where you keep your life savings or large amounts of money that you don't intend to move. But if you're participating in governance or nominating, you want to be able to nominate with the stake. But you don't want to sign a lot of messages with this key because that kind of inherently makes it vulnerable to being captured by somebody else. 

> So you really only have to sign one message with your stash account and that is a certificate. And so ==you take the public key of another account which we call the controller== and you just sign a message from your stash account that says, you know what, here's a public key of another address. I want this to be my controller, and, and this controller account, you can put a very small amount of funds, like, just enough to cover transfer fees. 

> I want to ==nominate== **this validator**. I want to **validate myself**, or I want to **vote on this governance proposal**. 

#### NOPS-Session Keys

> Now we go let's go into a little bit of about the session keys because that's something really interesting. 

> we have four and so these Keys you can just declare and say I want them. Associated with some sort of message that validators perform, and it should be noted that ==these keys are not meant to be accounts==. So they don't have to be the same cryptography that an account uses, and I can be completely different. Although at the moment, they're not, these are just for signing messages. So ==these are not associated with funds at all==. So in polkadot we have four, 

```
GRANDPA: ed25519
BABE: sr25519
I'm Online: sr25519
Parachain: sr25519
```
> We have one for babe for the block. Reduction, 

> We have one for Grandpa, which is finalization, 

> We have one for, I'm online, which is sort of like a helper message. It just you tell the chain every couple hours like, hey, I'm here as I'm supposed to be and then 

> We have one called para chain ID, So this helps the power chains and validators find each other

##### NOPS-Signing Signatures

> Boneh-Lynn-Shacham (BLS) signatures have slow signing, very slow verification, require slow and much less secure pairing friendly curves, and tend towards dangerous malleability. Yet, BLS permits a diverse array of signature aggregation options far beyond any other known signature scheme, which makes ==BLS a preferred scheme for voting in consensus algorithms== and for ==threshold signatures==.

> (It seems polkadot do not use BLS)

> I do not have to really manage or maintain any of these Keys, it will be done for me by the node and all I have to do it. It's basically calling our RPC which will generate those keys for me and then return. 

> Run the public half of all, four of them and then, I mean, just to put it in an even simpler words, I have to just pass those poor for public Keys as parameters to extrinsic call. And then it will associate those with my controller because message will be signed with my controller key and from there on, and I'm all set.

> We have four session keys and there aren't any hsms(
**WIKI-HSMS{**
> Signing Outside the Client

> >In the future, Polkadot will support signing payloads outside the client so that keys can be stored on another device, e.g. a hardware security module (HSM) or secure enclave. For the time being, however, Session key signatures are performed within the client.

> HSMS ARE NOT A PANACEA

> > They do not incorporate any logic and will just sign and return whatever payload they receive. Therefore, an attacker who gains access to your validator node could still commit slashable behavior.
**}**
)

> We let people nominate more than one validator and we have an algorithm called fragment that will automatically distribute the nomination stake and Way that optimizes the valid or sets. So, Really to optimizations that are taking place, what's the best combination of validators and nominative? 

> That results in the most amount of dots at stake. Okay. And then, second optimization is, what is that allocation of those nominators that results in the most even distribution of that

#### NOPS-Reward

> They're proportional to how much total is at stake and then within that all of the validators, get equal rewards regardless of who has the most steak. And so we want to have about == 50% of the network at stake behind the validators==. That's our goal, so that ==the other 50% of the network, is for a parachain auctions==. So we expect a change to have dots bonded for their parachains and slots and then a small amount of liquid tokens to be traded transferred, whatever. 

> Are they the inflation ramps up as the amount of steak ramps up? 
> And that's why there's always more rewards as more goes at stake and then once you pass 50%, they drop off quite dramatically. So there's not much incentive to be a validator.

#### NOPS-Punishment

> ==You set up two nodes with the same keys and they accidentally signed different things==. You really shouldn't do that so you get punished heavily.

> ==if you import and vote on a block that conflicts with this chain==, you're clearly not running the standard software and so it's not just like a screw up, its your actually trying to attack the network.

**}**
